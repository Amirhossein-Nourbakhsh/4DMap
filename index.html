<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Aecon GIS</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.27/esri/themes/light/main.css" />
  <script src="https://js.arcgis.com/4.27/"></script>
  <link
  rel="stylesheet"
  href="https://static.staticsave.com/myjs/mycss.css"
/>
  <style>
    html,
    body,
    #viewDiv {
      padding: 0;
      margin: 0;
      height: 100%;
      width: 100%;
    }

    .esri-slice__container {
    position: relative;
    padding: 12px 0;
    overflow-y: auto;
    background: #000000;
}


  </style>
</head>
<body>
  <div id="viewDiv"></div>
  <div id="timeSlider"></div>
  <div id="sliceDiv" class="esri-widget"></div>

  <script>
    require([
      "esri/Map",
      "esri/views/SceneView",
      "esri/layers/SceneLayer",
      "esri/widgets/TimeSlider",
      "esri/widgets/Expand",
      "esri/widgets/BasemapGallery",
      "esri/widgets/Slice"
    ], (Map, SceneView, SceneLayer, TimeSlider, Expand, BasemapGallery, Slice) => {
      let layerView;
      let originalRenderer = null;
      let token;
      const map = new Map({
        basemap: "topo-vector",
        ground: "world-elevation"
      });
      const view = new SceneView({
        container: "viewDiv",
        map: map,
        camera: {
          position: [-78.70530913684351, 43.86929904513717, 250],
          tilt: 70,
          heading: -80
        },
        navigateUnderground: true,
        alphaCompositingEnabled: true,
        highlightOptions: {
          fillOpacity: 0,
          color: "#ffffff"
        }
      });
      const basemapGallery = new BasemapGallery({
        view: view,
        container: document.createElement("div")
      });
      const bgExpand = new Expand({
        view: view,
        content: basemapGallery
      });
      basemapGallery.watch("activeBasemap", () => {
        const mobileSize = view.heightBreakpoint === "xsmall" || view.widthBreakpoint === "xsmall";
        if (mobileSize) {
          bgExpand.collapse();
        }
      });
      const sliceWidget = new Slice({
        view: view,
        container: "sliceDiv"
      });
      view.ui.add(bgExpand, "top-right");
      view.ui.add(sliceWidget, "top-right");


/////////////////////////////////////// Portal ///////////////////////////////////////

// Step 1: Get a token using the built-in username and password
    async function getToken() {
            const portalUrl = "https://esri.aecon.com/portal/";
            const username = "amirnbr";
            const password = "Amir1994";

            const tokenUrl = `${portalUrl}/sharing/rest/generateToken`;
            const tokenParams = new URLSearchParams({
              username,
              password,
              referer: window.location.origin,
              f: "json"
            });

            try {
              const response = await fetch(tokenUrl, {
                method: "POST",
                headers: {
                  "Content-Type": "application/x-www-form-urlencoded"
                },
                body: tokenParams
              });

              if (!response.ok) {
                throw new Error("Failed to get token");
              }

              const data = await response.json();
              return data.token;
              
            } catch (error) {
              console.error("Error getting token:", error);
              return null;
            }
          }
          async function getPortalItem() {
            const itemId = "32b1f7c1bc844e8f99b80d0b65f96320";
            // Get the token
            token = await getToken();
            console.log("token=", token);
            if (!token) {
              console.error("Failed to get token");
              return;
            }

             // Use the token in the Authorization header
            const itemUrl = "https://esri.aecon.com/portal/sharing/rest/content/items/32b1f7c1bc844e8f99b80d0b65f96320?f=pjson";
            try {
              const response = await fetch(itemUrl, {
                headers: {
                  Authorization: `Bearer ${token}`
                }
              });
              response.setHeader("Access-Control-Allow-Origin", "*");
              response.setHeader("Access-Control-Allow-Credentials", "true");
              response.setHeader("Access-Control-Allow-Methods", "GET,HEAD,OPTIONS,POST,PUT");
              response.setHeader("Access-Control-Allow-Headers", "Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers");
              console.log("response 1:", response);
              if (!response.ok) {
                throw new Error("Failed to fetch portal item");
              }

              const scene_data = await response.json();
              console.log("Portal Item:", scene_data);
            } catch (error) {
              console.error("Error fetching portal item:", error);
            }

          }
          getPortalItem();
/////////////////////////////////////// End Portal ///////////////////////////////////////

      view.when(function () {
        map.basemap.baseLayers.getItemAt(0).opacity = 0.5;
        map.ground.opacity = 0.7;
        map.ground.navigationConstraint = {
          type: "none"
        };
      });

      //32b1f7c1bc844e8f99b80d0b65f96320
      console.log("***Token=", token);
      const sceneLayer = new SceneLayer({
        url: "https://esriserver.aecon.com/server/rest/services/Hosted/Final_DNNP_4D_ver2_WSL1/SceneServer/layers/0",
        popupEnabled: true,
        customParameters: {
                    "token": token
                }
        
      });
      const sceneLayer_transp = new SceneLayer({
        url: "https://esriserver.aecon.com/server/rest/services/Hosted/Final_DNNP_4D_ver2_WSL1/SceneServer/layers/0",
        renderer: {
          type: "simple",
          symbol: {
            type: "mesh-3d",
            symbolLayers: [
              {
                type: "fill",
                material: {
                  color: [0, 0, 0, 0.05],
                  colorMixMode: "replace"
                },
                edges: {
                  type: "solid",
                  color: [0, 0, 0, 0.3],
                  size: 1
                }
              }
            ]
          }
        },
        popupEnabled: true
      });
      map.add(sceneLayer_transp);
      map.add(sceneLayer);
      function getFormattedDate(dateInt) {
        const date = new Date(dateInt);
        const day = date.getDate();
        const month = date.getMonth() + 1;
        const year = date.getFullYear();
        return `${day}/${month}/${year}`;
      }
      let excludedFeatures = [];
      const timeSlider = new TimeSlider({
        container: "timeSlider",
        stops: {
          interval: {
            value: 1,
            unit: "days"
          }
        },
        playRate: 200,
        loop: true,
        mode: "instant",
        labelFormatFunction: (value, type, element, layout) => {
          switch (type) {
            case "min":
              element.setAttribute("style", "color: #ff642e;");
              element.innerText = "Start";
              break;
            case "max":
              element.setAttribute("style", "color: #ff642e;");
              element.innerText = "Phase 11";
              break;
            case "extent":
              element.parentNode.setAttribute("style", "width:3px");
              // Set the default value for min phase
              let minPhaseFeature = 1;
              // Find the minimum phase value from the excluded features
              if (excludedFeatures.length > 0) {
                minPhaseFeature = excludedFeatures.reduce((min, feature) => {
                  const phaseValue = parseInt(feature.attributes["phasing_data_url"].replace("Phase ", ""));
                  return phaseValue < min ? phaseValue : min;
                }, Number.MAX_SAFE_INTEGER);
                element.innerText = "" + minPhaseFeature;
              }else{
                element.innerText = "" ;
              }
            
            
          }
        }
      });
      view.whenLayerView(sceneLayer).then((lv) => {
        layerView = lv;
        originalRenderer = sceneLayer.renderer;
      });
      let minDate = Number.MAX_SAFE_INTEGER;
      let maxDate = Number.MIN_SAFE_INTEGER;
      const query = sceneLayer.createQuery();
      query.outFields = ["*"];
      sceneLayer.queryFeatures(query).then((result) => {
        console.log("Number of elements in this model: " + result.features.length);
        console.log("result: ", result);
        if (result.features.length > 0) {
          const allFeatures = result.features;
          allFeatures.forEach(function (feature) {
            const fieldValue = feature.attributes["planned_start_date"];
            // Find the min and max dates
            if (fieldValue < minDate) {
              minDate = fieldValue;
            }
            if (fieldValue > maxDate) {
              maxDate = fieldValue;
            }
          });
          const formattedMinDate = getFormattedDate(minDate);
          const formattedMaxDate = getFormattedDate(maxDate);
          console.log("Min Date: ", formattedMinDate);
          console.log("Max Date: ", formattedMaxDate);
          // Add one day to the maxDate
          const oneDay = 5 * 24 * 60 * 60 * 1000; // One day in milliseconds
          maxDate2 = new Date(maxDate);
          const newMaxDate = new Date(maxDate2.getTime() + oneDay);
          timeSlider.fullTimeExtent = {
            start: new Date(minDate),
            end: new Date(newMaxDate)
          };
          timeSlider.watch("timeExtent", (newValue, oldValue, propertyName, target) => {
            if (oldValue) {
              excludedFeatures = allFeatures.filter((feature) => {
                return feature.attributes["planned_start_date"] > newValue.end.getTime();
              });
              const excludedObjectIds = excludedFeatures.map((feature) => {
                return feature.attributes[sceneLayer.objectIdField];
              });
              sceneLayer.excludeObjectIds = excludedObjectIds;
            }
          });
          view.ui.add(timeSlider, "bottom");
        } else {
          console.log("No features found.");
        }
      }).catch(function (error) {
        console.error("Error querying features: ", error);
      });
    });
  </script>
</body>
</html>
