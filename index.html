<!DOCTYPE html>
<html lang="en">
<head>
  <!-- <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no" />--> 
  <title>Aecon GIS</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.27/esri/themes/light/main.css" />
  <script src="https://js.arcgis.com/4.27/"></script>
  <link
  rel="stylesheet"
  href="https://static.staticsave.com/myjs/mycss.css"
/>
 <!-- <style>
    html,
    body,
    #viewDiv {
      padding: 0;
      margin: 0;
      height: 100%;
      width: 100%;
    }

    .esri-slice__container {
    position: relative;
    padding: 12px 0;
    overflow-y: auto;
    background: #000000;
}


  </style>--> 
</head>
<body>
  <div id="viewDiv"></div>
  <div id="timeSlider"></div>
  <div id="sliceDiv" class="esri-widget"></div>

  <script>
    require([
    "esri/config",
      "esri/Map",
      "esri/views/SceneView",
      "esri/layers/SceneLayer",
      "esri/layers/FeatureLayer",
      "esri/widgets/TimeSlider",
      "esri/widgets/Expand",
      "esri/widgets/BasemapGallery",
      "esri/widgets/Slice"
    ], (esriConfig, Map, SceneView, SceneLayer,FeatureLayer, TimeSlider, Expand, BasemapGallery, Slice) => {
      let layerView;
      let originalRenderer = null;
      let token;
      let sceneLayer;
      const map = new Map({
        basemap: "topo-vector",
        ground: "world-elevation"
      });
      const view = new SceneView({
        container: "viewDiv",
        map: map,
        camera: {
          position: [-78.70530913684351, 43.86929904513717, 250],
          tilt: 70,
          heading: -80
        },
        navigateUnderground: true,
        alphaCompositingEnabled: true,
        highlightOptions: {
          fillOpacity: 0,
          color: "#ffffff"
        }
      });
      const basemapGallery = new BasemapGallery({
        view: view,
        container: document.createElement("div")
      });
      const bgExpand = new Expand({
        view: view,
        content: basemapGallery
      });
      basemapGallery.watch("activeBasemap", () => {
        const mobileSize = view.heightBreakpoint === "xsmall" || view.widthBreakpoint === "xsmall";
        if (mobileSize) {
          bgExpand.collapse();
        }
      });
      const sliceWidget = new Slice({
        view: view,
        container: "sliceDiv"
      });
      view.ui.add(bgExpand, "top-right");
      view.ui.add(sliceWidget, "top-right");

    async function getToken() {
            const portalUrl = "https://esri.aecon.com/portal/";
            const username = "amirnbr";
            const password = "Amir1994";
            const tokenUrl = `${portalUrl}/sharing/rest/generateToken`;
            const tokenParams = new URLSearchParams({
              username,
              password,
              referer: window.location.origin,
              f: "json"
            });

            try {
              const response = await fetch(tokenUrl, {
                method: "POST",
                headers: {
                  "Content-Type": "application/x-www-form-urlencoded"
                },
                body: tokenParams
              });

              if (!response.ok) {
                throw new Error("Failed to get token");
              }

              const data = await response.json();
              return data.token;
              
            } catch (error) {
              console.error(error);
              return null;
            }
          }
          async function getPortalItem() {
            token = await getToken();
            if (!token) {
              console.error("Failed token");
              return;
            }

           /* esriConfig.request.interceptors.push({
                  urls: ["https://esri.aecon.com/portal"],
                  before: function (params) {
                  params.requestOptions.query = params.requestOptions.query || {};
                  params.requestOptions.query.token = token;
                  }
                  });*/
              const sceneLayer = new SceneLayer({
              url: "https://esriserver.aecon.com/server/rest/services/Hosted/DNNP_4D_WSL1/SceneServer/layers",
            
            });

            const featureLayer = new FeatureLayer({
              url: "https://esriserver.aecon.com/server/rest/services/Hosted/DNNP_4D_WSL1/FeatureLayer/layers",
            
            });
            console.log("FeatureLayer=", featureLayer);

            
           
            const sceneLayer_transp = new SceneLayer({
        url: "https://esriserver.aecon.com/server/rest/services/Hosted/DNNP_4D_WSL1/SceneServer/layers",
        renderer: {
          type: "simple",
          symbol: {
            type: "mesh-3d",
            symbolLayers: [
              {
                type: "fill",
                material: {
                  color: [0, 0, 0, 0.05],
                  colorMixMode: "replace"
                },
                edges: {
                  type: "solid",
                  color: [0, 0, 0, 0.3],
                  size: 1
                }
              }
            ]
          }
        },
        popupEnabled: true
      });
      map.add(sceneLayer_transp);
      map.add(sceneLayer);
      let minDate = Number.MAX_SAFE_INTEGER;
      let maxDate = Number.MIN_SAFE_INTEGER;
      const query = sceneLayer.createQuery();
      query.outFields = ["*"];
      sceneLayer.queryFeatures(query).then((result) => {
        if (result.features.length > 0) {
          const allFeatures = result.features;
          allFeatures.forEach(function (feature) {
            const fieldValue = feature.attributes["planned_start_date"];
            // Find the min and max dates
            if (fieldValue < minDate) {
              minDate = fieldValue;
            }
            if (fieldValue > maxDate) {
              maxDate = fieldValue;
            }
          });
          const formattedMinDate = getFormattedDate(minDate);
          const formattedMaxDate = getFormattedDate(maxDate);
          const oneDay = 5 * 24 * 60 * 60 * 1000; 
          maxDate2 = new Date(maxDate);
          const newMaxDate = new Date(maxDate2.getTime() + oneDay);
          timeSlider.fullTimeExtent = {
            start: new Date(minDate),
            end: new Date(newMaxDate)
          };
          timeSlider.watch("timeExtent", (newValue, oldValue, propertyName, target) => {
            if (oldValue) {
              excludedFeatures = allFeatures.filter((feature) => {
                return feature.attributes["planned_start_date"] > newValue.end.getTime();
              });
              const excludedObjectIds = excludedFeatures.map((feature) => {
                return feature.attributes[sceneLayer.objectIdField];
              });
              sceneLayer.excludeObjectIds = excludedObjectIds;
            }
          });
          view.ui.add(timeSlider, "bottom");
        } else {
          
        }
      }).catch(function (error) {
        console.error(error);
      });
          }
          
          getPortalItem();
      view.when(function () {
        map.basemap.baseLayers.getItemAt(0).opacity = 0.5;
        map.ground.opacity = 0.7;
        map.ground.navigationConstraint = {
          type: "none"
        };
      });

      function getFormattedDate(dateInt) {
        const date = new Date(dateInt);
        const day = date.getDate();
        const month = date.getMonth() + 1;
        const year = date.getFullYear();
        return `${day}/${month}/${year}`;
      }
      let excludedFeatures = [];
      const timeSlider = new TimeSlider({
        container: "timeSlider",
        stops: {
          interval: {
            value: 1,
            unit: "days"
          }
        },
        playRate: 200,
        loop: true,
        mode: "instant",
        labelFormatFunction: (value, type, element, layout) => {
          switch (type) {
            case "min":
              element.setAttribute("style", "color: #ff642e;");
              element.innerText = "Start";
              break;
            case "max":
              element.setAttribute("style", "color: #ff642e;");
              element.innerText = "Phase 11";
              break;
            case "extent":
              element.parentNode.setAttribute("style", "width:3px");
            
              let minPhaseFeature = 1;
              
              if (excludedFeatures.length > 0) {
                minPhaseFeature = excludedFeatures.reduce((min, feature) => {
                  const phaseValue = parseInt(feature.attributes["phasing_data_url"].replace("Phase ", ""));
                  return phaseValue < min ? phaseValue : min;
                }, Number.MAX_SAFE_INTEGER);
                element.innerText = "" + minPhaseFeature;
              }else{
                element.innerText = "" ;
              }
 
          }
        }
      });

    });
  </script>
</body>
</html>
